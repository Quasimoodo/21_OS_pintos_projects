要做的东西：
  /threads
  /devices

//老师的要求：
  将已有代码和目标之间做一个需求分析
//官方的要求：

文档写作：重要
  数据结构：
    说明新增或改变的结构体、全局或静态变量等，并附简短说明（25words)
  算法：
    说明代码如何工作，（原理上的），参考assignment写作
    Mission 1：
      形容在调用timer_sleep()的时候发生了什么，包括中断应对器(?)的效果
      如何让中断应对器(timer interrupt handler)少花时间？
    Mission 2：

    Mission 3：
  同步：
    选择某一特定同步方法的理由
    Mission 1：
      多线程调用时，如何解决timer_sleep()的竞争？
      调用timer_sleep()时发生中断，如何解决？
  基本原理：
    设计决策的合理性，可以从时空复杂度出发，不需要证明(还要说到其他考虑到但没有使用的设计模式，优越之处何在)

    具体pintos文档模板见.\template_threads.tmpl

Mission 1:
重新实现timer_sleep()，在devices / timer.c中定义
  重新实现其功能（已有），但改变其忙等待机制（busy waiting)
   忙等待：连续测试某一变量直到其出现某一值为止。
  现在的实现方式：循环，不断调用thread_yield()，直到经过了足够的时间。

  功能：暂停进程，在指定时间（timer ticks)后，将其加入ready queue中

  Mission 2：
  解决优先级调度问题：
  thread / thread.c
  当一个有着更高优先级的线程被添加到就绪列表中，当前线程应该切换。
  当线程被阻塞时，也应就绪列表中的最高优先级线程。
  实现以下函数：
   void thread_set_priority（int new_priority）
    将当前线程的优先级设置为new_priority。如果当前线程不再具有最高优先级，则屈服。
   int thread_get_priority（void）
    返回当前线程的优先级。在存在优先级捐赠的情况下，返回较高（捐赠的）优先级。
  主要问题:
   优先级倒置
   (?)为什么会有这种问题
   不会在以后使用
 Mission 3：
  高级优先级调度：
  模拟？




Misssion 1:
 assert :断言：若表达式结果为假，则报错
 enum：枚举，包含多个无符号整数的集合，值递增1

 整个大概的流程：
 首先，尽量把loops_per_tick尽量搞大（用 too_many_loops())（分别高、低位，较快
   too_many_loopsd的逻辑：
    先等到一个整点tick，当经过了这么多循环后，返回是否还在同一个tick间隔内
 ，让其尽可能大，可以比较少的占用cpu资源？
 其次，整个程序中大致分为两类函数，delay和sleep，
sleep类函数：
必须设置为可中断
调用real_time_sleep(),这个函数会计算出滴答数后调用timer_sleep，
     timer_sleep： 在没有到达某滴答前令进程持续yield（）,即
       将线程在一定时间内，若在running则持续扔回就绪队列
如果不足1个滴答，就调用real_time_delay（）进行等待。

delay类函数：
不必要设置成可中断
同样调用real_time_delay进行
      real_time_delay（）：调用busy_wait()混日子
      busy_wait()：一个防止优化的持续减法循环，地道的忙等待

timer_interrupt 和timer_ticks()暂时还没看懂
timer_ticks():获得当前ticks数，前屏蔽中断后恢复,即确保原子操作

yield():
//将当前线程加入就绪队列，重新schedule()，若就绪队列为空，则交给空闲进程（当前继续运行？）
{
    确保没有外中断
    原子化操作：如果当前线程非空闲，就将其放入就绪队列。将其状态改为就绪，之后schedule()

schedule()//拿下一个线程过来run
 {
  获取当前线程和
  下一个线程
  {
    就绪队列第一个或空闲进程
  }
  然后三个断言：
  {
    外中断屏蔽
    当前线程运行
    下一个线程指向的是个线程
  }
  当前线程和下一个不是同一个则调用
  switch_threads()
  {
    汇编实现，保存当前线程状态，切换到下一个线程，恢复到下一个线程的之前状态
    返回的当前线程即为prev
  }
  返回prev前一个线程
  最后调用thread_schedule_tail (prev)//获取当前线程，恢复之前状态，如果当前线程死了就清空资源
  //dying应该是死而未释放的意思

  {
    获取当前线程，断言关中断，
    将当前状态设置为正在运行，重置时间片为0
    调用process_activate ()
    {
      更新页目录表，
      更新现场信息TSS
    }
    如果prev(不是 当前运行的线程/初始线程 且是dying的)
    将其
    palloc_free_page(),即销毁
    {
      palloc_free_multiple()//核心
      {
        大概就是判断其是内核线程还是用户线程，然后将页清零？
      }
    }
  }

 }
}
每一个线程有自己的寄存器可用
页表：
  开启页表选项后，只允许访问虚拟内存，MMU(内存管理模块)通过页表将虚拟地址转化为物理地址
 原理：
  将物理内存空间的帧映射到虚拟内存空间的帧

is_thread()
{
  s是否指向有效线程
}

问题：
 
  为什么timer.c 99，100行的内容必须？——看看测试用例
  如何实现的每个tick调用一次中断？
解决:
 将timer_sleep()的内容重做：
 原子操作：设定当前线程的toblock数，然后将其block。在block期间是不响应中断的，block():直接schedule()
 在每个timer_interrupt()的时候，调用将每个线程检查其block，若正在block，则减一个ticks，若ticks_toblock为0，则将其unblock()；
 unblock():将其放入readyqueue中
 同时设置创建时的toblock为0；aob
 //这里应该可以把那两句改掉




mission 2
 根据文档的设计，getpri和setpri都只需要实现对本现成的优先级调整就可以了
 
 先实现ready queue的优先队列，然后再实施优先级捐赠，实时轮转等功能。
 观察 已有的readyqueue怎么实现的：
   list_push_back (&ready_list, &t->elem);
   这一句可以将线程加入就绪队列，
   list_push_back ()这一句调用list_insert (),
   而ready queue的队列结构就是一个保存了头尾指针的双向链表

 要把这个双向链表用优先队列维护，看看有没有现成的？
  list_insert_ordered
  list_sort
  按序插入和排序 应该都能用到

在thread.c中搜索list_push_back()这种添加线程到就绪队列，发现只有
 thread_yield()
 thread_unblock()
 这两个函数这样用
 考虑改成list_insert_ordered
 list_insert_ordered (struct list *list, struct list_elem *elem,
                     list_less_func *less, void *aux)
                  考虑这个比较函数怎么实现
  照着list.h和别的引用线程的实现，完成函数
  bool thread_cmp_priority(const struct list_elem *a, const struct list_elem *b, void *aux)
  在thread.c的584行
  在thread.h的129行声明
  考虑在队列中的是线程结构体的list_elem,需要使用list_entry()函数来访问其结构体(以访问其pri)


thread_block, thread_exit, and thread_yield;这三个函数会调用schedule()

下来来看一些同步时的核心函数
主要应用的结构体是
lock
{
    struct thread *holder;      /* Thread holding lock (for debugging). */
    struct semaphore semaphore; /* Binary semaphore controlling access. */
  };
  struct semaphore 
  {
    unsigned value;             /* Current value. */
    struct list waiters;        /* List of waiting threads. */
  };
  锁和信号量这两个
lock_init()
{
  lock的holder=0；
  然后调用semaphore lock_init()
  {


  }
}
lock_acquire()
{
    断言所存在，无外中断，当前线程不持有锁
  sema_down()
  {
    原子操作：
    当sema的值==0时，将当前线程加入sema的waiterlist里，
    然后block掉
    获得锁了之后--
  

  }
}
//priority-change.c:在创建了新的线程和改变了当前线程优先级之后，就应该观察是否调整当前线程
——改了和创建了就yield？
//priority_preempt.c 创建了更高优先级的线程，将其不断yield但还每次轮到
/——创建了就yield (如果新的比现在的要高)
priority_sema.c 依次创建若干pri逐渐下降的线程，然后再释放锁。在每个县城内部等待锁
——感觉只要实现最朴素的优先级捐赠就可以过
——要考虑信号量更改了
priority_fifo.c 大概是创建若干优先级相同而低于当前线程的线程，在内部不断重复获得锁——释放锁——yield的过程而保证其线程队列顺序不变
——应该可以不用捐赠直接过？ 

thread_create()，创建了就加入到就绪队列里

对priority-donate-one的研究：
在lock中记录一个pri,在acquire的时候记录其值，同时在等待锁的时候，acquire中加入检测锁的pri并重置
在thread结构体中加一个被set的priority的栈，不断适应并逐级弹出

维护的锁的waitlist也应该改成优先队列？












问题：
  为什么sema_down可以屏蔽那么久的中断？——仅当前线程
  一个线程的函数执行完了会咋样？//dying，exit（）之后
  到底哪里需要屏蔽中断？


`struct thread' is always at the beginning of a page
