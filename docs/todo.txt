要做的东西：
  /threads
  /devices

//老师的要求：
  将已有代码和目标之间做一个需求分析
//官方的要求：

文档写作：重要
  数据结构：
    说明新增或改变的结构体、全局或静态变量等，并附简短说明（25words)
  算法：
    说明代码如何工作，（原理上的），参考assignment写作
    Mission 1：
      形容在调用timer_sleep()的时候发生了什么，包括中断应对器(?)的效果
      如何让中断应对器(timer interrupt handler)少花时间？
    Mission 2：

    Mission 3：
  同步：
    选择某一特定同步方法的理由
    Mission 1：
      多线程调用时，如何解决timer_sleep()的竞争？
      调用timer_sleep()时发生中断，如何解决？
  基本原理：
    设计决策的合理性，可以从时空复杂度出发，不需要证明(还要说到其他考虑到但没有使用的设计模式，优越之处何在)

    具体pintos文档模板见.\template_threads.tmpl

Mission 1:
重新实现timer_sleep()，在devices / timer.c中定义
  重新实现其功能（已有），但改变其忙等待机制（busy waiting)
   忙等待：连续测试某一变量直到其出现某一值为止。
  现在的实现方式：循环，不断调用thread_yield()，直到经过了足够的时间。

  功能：暂停进程，在指定时间（timer ticks)后，将其加入ready queue中

  Mission 2：
  解决优先级调度问题：
  thread / thread.c
  当一个有着更高优先级的线程被添加到就绪列表中，当前线程应该切换。
  当线程被阻塞时，也应就绪列表中的最高优先级线程。
  实现以下函数：
   void thread_set_priority（int new_priority）
    将当前线程的优先级设置为new_priority。如果当前线程不再具有最高优先级，则屈服。
   int thread_get_priority（void）
    返回当前线程的优先级。在存在优先级捐赠的情况下，返回较高（捐赠的）优先级。
  主要问题:
   优先级倒置
   (?)为什么会有这种问题
   不会在以后使用
 Mission 3：
  高级优先级调度：
  模拟？




Misssion 1:
 assert :断言：若表达式结果为假，则报错
 enum：枚举，包含多个无符号整数的集合，值递增1

 整个大概的流程：
 首先，尽量把loops_per_tick尽量搞大（用 too_many_loops())（分别高、低位，较快
   too_many_loopsd的逻辑：
    先等到一个整点tick，当经过了这么多循环后，返回是否还在同一个tick间隔内
 ，让其尽可能大，可以比较少的占用cpu资源？
 其次，整个程序中大致分为两类函数，delay和sleep，
sleep类函数：
必须设置为可中断
调用real_time_sleep(),这个函数会计算出滴答数后调用timer_sleep，
     timer_sleep： 在没有到达某滴答前令进程持续yield（）,即
       将线程在一定时间内，若在running则持续扔回就绪队列
如果不足1个滴答，就调用real_time_delay（）进行等待。

delay类函数：
不必要设置成可中断
同样调用real_time_delay进行
      real_time_delay（）：调用busy_wait()混日子
      busy_wait()：一个防止优化的持续减法循环，地道的忙等待

timer_interrupt 和timer_ticks()暂时还没看懂
timer_ticks():获得当前ticks数，前屏蔽中断后恢复,即确保原子操作

yield():
//将当前线程加入就绪队列，重新schedule()，若就绪队列为空，则交给空闲进程（当前继续运行？）
{
    确保没有外中断
    原子化操作：如果当前线程非空闲，就将其放入就绪队列。将其状态改为就绪，之后schedule()

schedule()//拿下一个线程过来run
 {
  获取当前线程和
  下一个线程
  {
    就绪队列第一个或空闲进程
  }
  然后三个断言：
  {
    外中断屏蔽
    当前线程运行
    下一个线程指向的是个线程
  }
  当前线程和下一个不是同一个则调用
  switch_threads()
  {
    汇编实现，保存当前线程状态，切换到下一个线程，恢复到下一个线程的之前状态
    返回的当前线程即为prev
  }
  返回prev前一个线程
  最后调用thread_schedule_tail (prev)//获取当前线程，恢复之前状态，如果当前线程死了就清空资源
  //dying应该是死而未释放的意思

  {
    获取当前线程，断言关中断，
    将当前状态设置为正在运行，重置时间片为0
    调用process_activate ()
    {
      更新页目录表，
      更新现场信息TSS
    }
    如果prev(不是 当前运行的线程/初始线程 且是dying的)
    将其
    palloc_free_page(),即销毁
    {
      palloc_free_multiple()//核心
      {
        大概就是判断其是内核线程还是用户线程，然后将页清零？
      }
    }
  }

 }
}
每一个线程有自己的寄存器可用
页表：
  开启页表选项后，只允许访问虚拟内存，MMU(内存管理模块)通过页表将虚拟地址转化为物理地址
 原理：
  将物理内存空间的帧映射到虚拟内存空间的帧

is_thread()
{
  s是否指向有效线程
}

问题：
 
  为什么timer.c 99，100行的内容必须？
  如何实现的每个tick调用一次中断？
解决:
 将timer_sleep()的内容重做：
 原子操作：设定当前线程的toblock数，然后将其block。在block期间是不响应中断的，block():直接schedule()
 在每个timer_interrupt()的时候，调用将每个线程检查其block，若正在block，则减一个ticks，若ticks_toblock为0，则将其unblock()；
 unblock():将其放入readyqueue中
 同时设置创建时的toblock为0；


